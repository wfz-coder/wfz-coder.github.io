[{"title":"大模型交互式教学原则","path":"/2025/07/25/大模型交互式教学原则/","content":"如何利用好大模型作为先进生产力是当下打工牛马的重要课题，其中一个很好的应用方面，我认为是让大模型来教你学新知识，因为编程牛马必须不停地接受新知识，而这对学习效率很有要求 大模型本质上是非确定性模型，知识丰富但有幻觉，如果提问不当会给出质量较差的回答。我们应当把大模型想象成一个能力极强、知识渊博、绝对服从，但毫无经验、缺乏常识的学生，而我们则作为导师从高层指导它一些原则或方法，尽管我们对其中具体的实现方式并不了解。不过，在官方不公开的情况下，我们只能尽量自己设计更好的 prompt 结构，以获取较佳的回答 受到 arxiv 上某科研团队利用提示词工程帮助 Google Gemini 成功攻克 imo 金牌的启发，我自己也和 Gemini 一同讨论，并且得到了一套有助于 AI 指导用户并自我改进回答质量的 prompt，作为笔记记录于此。它本身也可通过 url 的形式导入给 Gemini，从而节约一些 token （需开启 url context 能力） 1. 规划原则：蓝图先行，分步实施 (Blueprint First, Incremental Implementation) 创建“单一事实来源” (Single Source of Truth): 对于任何长期或复杂的任务，投入时间与AI共同打磨并最终确定一份详尽的、作为最高指导的顶层规划文档（即“蓝图”）。这份蓝图是所有后续工作的基石。 增加“方法概述” (Method Sketch): 在每个主要阶段（Phase）开始之前，要求AI先提供一个高层、概念性的“方法概述”。此概述应阐明本阶段的总体策略、核心目标和逻辑流程，以便在深入细节前建立清晰的战略认知。 坚持“原子单元” (Atomic Units): 将宏观规划分解为一系列独立的、认知负荷极低的、可独立验证的执行单元。每个单元应只解决一个核心问题，确保学习和开发过程的平滑与可控。 2. 交付原则：结构清晰，诚实严谨 (Structured, Honest, and Rigorous Delivery) 制定交付规范 (Standardized Deliverables): 与AI共同确立一套标准化的交付格式（例如，“五段式教学单元”）。这不仅规定了“做什么”，更定义了“怎么交付”，确保每次产出的质量和结构一致，便于理解和验证。 强调“完整性诚实” (Honesty About Completeness): 要求AI在其解决方案中明确声明任何局限性、存在的替代方案或潜在的风险。AI不应提供看似完美但可能包含隐藏缺陷或论证空白的方案。如果只能提供部分解决方案，必须明确指出。 分离“实现”与“解释” (Separation of Implementation and Explanation): 在交付代码时，可以要求AI提供两个版本： 纯净实现代码 (Clean Implementation): 不含任何解释性注释，代表最终可用于生产或集成的代码。 带详细注释的教学代码 (Annotated Code): 包含对关键逻辑、设计决策和API用法的详细解释，用于学习和理解。 3. 交互原则：角色明确，反馈精准 (Clear Roles, Precise Feedback) 扮演“验证者” (Act as the Verifier): 在协作中，用户应主动扮演“验证者”或“评审者”的角色。持续对AI提供的方案、代码和解释进行批判性审视，挑战其逻辑的严谨性和细节的准确性。 引入“问题分类” (Classify Issues): 当发现问题时，尝试使用结构化的分类法进行反馈，以提高沟通效率。借鉴研究中的分类： “严重错误 (Critical Error)”: 指那些破坏核心逻辑、导致功能失效或产生错误结果的问题（如代码bug、算法错误）。 “论证差距 (Justification Gap)”: 指那些方案可能可行，但AI的解释不充分、缺乏依据、或跳过了关键背景知识，导致“知其然不知其所以然”的情况。 指令自我修正 (Instruct for Self-Correction): 随时可以要求AI对其自身的回答进行迭代和优化，例如：“你刚才的解释在A点上存在论证差距，请补充更详细的理由。” 4. 流程原则：正视模型局限，设计外部化流程 (Bypass Limitations with Externalized Processes) 识别核心限制 (Acknowledge Core Limitations): 清晰地认识并接受AI模型固有的技术限制，如有限的上下文记忆、无法跨会话记忆等，并将其作为设计协作流程的前提。 外置核心状态 (Externalize the State): 设计一套不依赖AI记忆的工作流程。将项目的核心状态（如版本控制的代码、项目文档、进度列表）显式地、外部化地进行管理。在每次交互时，由用户主动将“当前状态”作为输入提供给AI，使其成为一个强大的、但无状态的“处理器”。","tags":["LLM"]},{"title":"调试与优化学习笔记","path":"/2025/07/10/调试与优化学习笔记/","content":"在很多时候，我们不仅要关注 C++ 程序的执行结果，还要关心程序的执行情况，如执行效率，这可以通过 perf 来实现。同时，如果程序在意想不到的地方崩溃了，而 IDE 无法给出详尽的错误原因，则需要我们手动去找出发生错误的地点，这可以通过 gdb 和 分析 coredump来实现 1gcc -g -o XXX XXX.c 为了让 GDB 能够显示源代码信息（例如行号、变量名），我们必须在编译时加入 -g 调试选项。这个选项能方便 coredump 和 perf 分析 1234gdb ./XXX(gdb) run(gdb) bt(gdb) quit 运行程序：输入 run（或简写为 r）查看出错的调用帧（看炸掉的点在哪）：输入 backtrace（或简写为 bt）退出调试：输入 quit (或简写为 q) 有时候程序在线上环境中崩溃，我们无法实时用 GDB 附加。这时 coredump 文件就成了救星 1ulimit -c unlimited 这个命令会允许生成不限大小的 coredump 文件。但此命令只在当前终端会话中有效在ubuntu server中，coredump 会被 &#x2F;usr&#x2F;share&#x2F;apport&#x2F;apport 吃掉，并把它变成自己的报告格式，临时解决方法： 1sudo sysctl -w kernel.core_pattern=core 此时，我们再去运行程序，就会在代码目录下同时生成 core 文件，可使用 gdb 将其打开 1gdb ./crash_program core.XXX perf 是一个性能分析工具，能获取程序运行时的基本性能统计数据，例如指令数、周期数和缓存命中率等 在不深入代码细节的情况下，可以使用 stat 来快速获得一个程序或整个系统的宏观性能概览 1sudo perf stat ./XXX 系统默认阻止非 root 用户使用 perf 这类强大的性能分析工具。因为 perf 可以监控到非常底层的系统信息，比如内核函数的调用、其他用户进程的活动等，如果不加限制，可能会导致信息泄露。知根知底的情况下，可以通过 sudo 的方式去绕开这一限制 123456789101112Performance counter stats for &#x27;./XXX&#x27;: 2395.59 msec task-clock # 0.994 CPUs utilized 71 context-switches # 29.638 /sec 2 cpu-migrations # 0.835 /sec 64 page-faults # 26.716 /sec &lt;not supported&gt; cycles 2.409789043 seconds time elapsed 2.395581000 seconds user 0.000996000 seconds sys 运行结束后，perf stat 会打印出一份报告，包含指令数、周期数、缺页中断数等信息。上述数据有助于判断是否多线程竞争，是 CPU 密集型任务，还是 I&#x2F;O 密集型任务等。例如，如果 time elapsed 远大于 task-clock，同时缺页中断又比较高，那就有可能是 I&#x2F;O 卡了 1perf trace -o XXX 此时，可以执行上述指令，去跟踪程序执行时文件系统的读写过程 当需要进一步地结合代码细节去看运行的情况，则可以运行： 1sudo perf record ./XXX 执行上述程序会输出一个 perf.data 文件，可以通过 perf report 读取，它是交互式的。里面是一个函数列表，按 CPU 占用率从高到低排列。可以通过 Annotate 功能去汇编层面上分析。其中，Overhead 是最重要的信息。它显示了在 perf record 采样期间，有多少比例的 CPU 时间命中了这一行汇编指令。百分比越高，说明 CPU 在执行这条指令上花费的时间越多 当一个 Bug 不是立刻出现，而是在大量循环之后才触发时，设置条件断点和观察点有助于避免手动单步调试的麻烦 12(gdb) break XXX.c:19 if i == 999(gdb) next 如果程序只会在一定次数后崩溃（如 for 循环），那其实类似上面那样可以设置条件断点。等到达断点后，再执行单步 更多时候，我们并不能知道错误点发生的原因，但可能只知道某个变量（指针）被错误的修改，从而导致上述错误的发生。这时便可以运用观察点观察该变量。例如： 12(gdb) watch XXX(gdb) continue gdb 会展示出变量修改前后的值，以及停下来所在的代码行。如果停下来的点不是预期点，可以执行 continue（或简写为 c） 有时候程序是以多线程执行的，此时分析 coredump 的方式会有所不同 123info threads(gdb) thread 1 (gdb) bt 执行 gdb 后，程序会列出很多个线程，或者也可以用 info threads 手动查看。此时，可以通过 thread + 数字 的方式去 bt 对应的线程，来查看它们各自停下来的点，从而拼凑出多线程执行时的具体情况（例如，死锁循环等待） 当性能瓶颈涉及多个函数调用时，可以使用调用图 (Call Graph) 来分析性能的来龙去脉 12perf record -F 99 -g ./XXXperf report 绘制调用图的关键在于加入 -g 选项。它告诉 perf 在采样时记录函数的调用关系。-F 99 选项指定采样频率为 99HZ，避免与系统计时器产生固定的相位关系 执行 perf report 后，在对应的行按下 + 号，就可以看到它的调用关系（展开列表里，该函数的上一行便是它的最近调用者），以及每一层所占用的资源比例 单纯的调用图可能还不够直观，这里可以通过网络上提供的脚本来生成对应的火焰图 12git clone https://github.com/brendangregg/FlameGraphperf script | ./FlameGraph/stackcollapse-perf.pl &gt; out.folded ./FlameGraph/flamegraph.pl out.folded &gt; XXX.svg 如何分析火焰图？ 对于X轴，看它的“平顶”的宽度，因为这是刨除它调用的函数后，自己执行的时间 对于Y轴，看他的层数，这代表调用栈的深度，同时也是函数调用关系的直观展示 如果说 gdb 能在程序崩溃后进行解剖，找出死因，那么 Valgrind 则能在程序运行时找出各种潜在的内存问题，哪怕这些问题还没有导致程序崩溃。这对于预防上述问题很有帮助 Valgrind 并不使程序直接在 CPU 上执行，而是将其代码翻译成一种中间形态，然后在 Valgrind 的虚拟 CPU 上执行。在这个过程中，Valgrind 可以对每一条内存访问、每一次函数调用进行插桩和检查。因为这种模拟执行的方式，程序将运行得非常慢，并且会消耗更多内存 当提及 Valgrind 时，95% 的场景是其使用默认工具 Memcheck，对潜在的内存泄漏问题进行分析 1valgrind --tool=memcheck --leak-check=full --show-leak-kinds=all ./XXX 使用上述指令来对各种泄露问题进行详细检查。还是一样，建议在 gcc 编译时加上 -g，以便在结果输出时显示行号。还可以通过附加 –track-origins&#x3D;yes 选项，以查找变量使用的脏数据来源 Valgrind 输出的报告会分为多个部分，分别是： 堆内存使用总结部分： 12in use at exit: X bytes in Y blockstotal heap usage: X allocs, Y frees, Z bytes allocated 通过分析这些数字的关系，则可以大概知道堆内存是否有泄露，但还需要看下面的详情部分 泄露详情部分： Conditional jump or move depends on uninitialised value(s) at X【未初始化值的使用】 Invalid write&#x2F;read of size Y at X 【越界读取或写入、使用已释放的内存】 Invalid free() &#x2F; delete &#x2F; delete[] &#x2F; realloc() at X 【重复释放】 泄漏类型总结部分： definitely lost (明确丢失)：通常发生于没有任何指针可以访问到这块内存 indirectly lost (间接丢失)：通常发生于类或结构体的明确丢失导致的成员丢失 possibly lost (可能丢失)：这是一种比较模糊的情况。Valgrind 发现有一个指针指向这块内存的内部，而不是头部。这可能是程序员在进行一些复杂的指针运算，也可能是一个真正的泄漏 still reachable (仍可访问)：程序退出时，仍然有指针指向这块内存（比如一个全局指针），但程序自始至终没有释放它。这算是一种懒惰的写法，在某些短生命周期的程序中可以接受，但在长时间运行的服务器程序中，这就是一种需要修复的资源泄漏 当然，在一个依赖中间件的复杂系统上，无法单独剥离某个模块来做 Valgrind 的分析，这种情况下就需要写单元测试了","tags":["Linux","C++","gdb","perf","Valgrind","coredump"]},{"title":"C++基础知识 学习笔记","path":"/2025/06/12/C++基础知识学习笔记/","content":"1. C++语言基础篇1、智能指针 智能指针是一个类模板，用于封装原始指针。它增加了析构函数成员 当智能指针对象离开它的作用域时，系统自动调用析构函数，从而免去了手动 delete 的麻烦 unique_ptr：独占所有权 当一个指针独占地管理一个动态分配的资源时适用 禁止了拷贝构造和拷贝赋值操作 如果确实需要转移所有权，必须显式地使用 move 来进行移动操作 shared_ptr：共享所有权 当多个指针需要指向并共同管理同一个对象时适用 通过引用计数维护共享成员数量，类似于硬链接 这也导致如果两个 shared_ptr 循环引用，则它们都无法释放，类似于死锁 weak_ptr：shared_ptr的助手 指向一个由 shared_ptr 管理的对象，但它不增加引用计数，只是一个观察者 weak_ptr不能直接解引用所指向的对象，必须先通过lock()检查 如果对象仍然存在，返回一个有效的 shared_ptr（此时引用计数会临时+1） 如果对象已被销毁，返回一个空的 shared_ptr 循环引用的一方或双方可以使用weak_ptr，这样就能避免释放失败的问题 2、内存区域划分 栈： 由编译器自动管理，分配和释放非常高效 用于存放函数参数、局部变量、函数返回地址、函数调用上下文 向低地址生长 堆： 用于按需动态内存分配，程序员手动管理，分配和释放更加复杂（类似操作系统空闲链表法） 堆的大小通常远大于栈，受限于系统的可用虚拟内存 向高地址生长 全局/静态存储区： 在编译链接时确定大小和位置，程序启动时分配，程序运行时存在，程序结束时回收 用于存储程序的全局变量和静态变量 可进一步细分为 .data 段(显式初始化)和 .bss 段(未显式初始化) 常量存储区： 即 .rodata 段，只读。用于存放程序中的常量值，如字符串字面值 代码区： 即 .text 段，用于存放程序执行代码（编译后的机器指令），只读 3、指针参数传递和引用参数传递 指针参数传递： 本质仍然是值传递，只不过传的是内存地址 指针传递允许函数通过地址来间接访问和修改调用者的变量 传入 nullptr 是可能的，所以需要在使用指针前进行检查 引用参数传递： 引用为变量提供了别名。引用传递利用这个特性，让函数直接操作原始变量 引用参数在函数调用时绑定到传入的实参，在函数内部不能再被重新绑定到其他变量 不能传入 nullptr 引用，必须绑定到一个有效的对象上 4、关键字相关 static： 修饰类数据成员：使该成员变成静态数据成员，由所有实例化的类对象共享 修饰类成员函数：与修饰类数据成员类似，但即使没有实例化也能使用 const： 修饰类成员函数：const 放在成员函数参数列表的后面，函数体的前面 const 修饰的成员函数只能调用该类的其他 const 成员函数 const 修饰的成员函数不能修改对象的任何非 static、非 mutable 数据成员 this 指针类型就是 const ClassName*（指向常量对象的指针） volatile: 用于告诉编译器，这个变量的值随时可能在代码之外被改变，所以不要对它做优化 在硬件寄存器更新、中断服务程序、其他线程参与这些场景下可以使用 override：显式检查重写的父类函数是否为 virtual，与重定义区分开 typedef：C 语言引入，用于为已存在的类型创建别名 相比#define，前者在预处理阶段执行，没有类型检查；后者在编译阶段，有类型检查 using: C++11 引入，和前者作用一致 形如：using ULL = unsigned long long; inline：向编译器建议将函数调用处替换为函数体本身的内联展开，从而提高执行效率 通常对短小、简单且频繁调用的函数使用 5、重载、重写、重定义的区别 重载： 期望在同一个作用域（类或命名空间）内，定义多个同名函数，参数列表必须不同 函数的返回类型不能作为区分重载函数的依据 重写： 期望子类函数重写父类 virtual 基函数，即实现多态 子类函数需要与父类函数签名完全一致 重定义： 期望子类函数按需重新实现父类非 virtual 基函数 如果子类函数和父类函数签名完全相同，通过子类对象/指针调用该函数时，执行子类的版本 通过父类对象/指针调用该函数时，执行父类的版本 如果子类函数和父类函数签名不完全一致，那么父类同名函数会被隐藏 6、构造函数 a) 默认构造函数 不接受任何参数 如果没有自行定义任何构造函数，编译器自己会生成，不包含异常处理机制 b) 参数化构造函数 c) 拷贝构造函数 用于根据一个已存在的同类对象来创建并初始化一个新的对象 如果没有自行定义，编译器自己会生成，并执行成员逐一拷贝 形如：MyClass(const MyClass&amp; other) &#123; /* ... */ &#125; 使用 const 引用的原因是防止拷贝出的对象递归调用拷贝构造函数 因为如果要值传递，就要生成副本。而生成副本，又需要重新调用构造函数 注意：如果类内有指针成员，则默认生成的拷贝构造函数只会把原来的值复制进去（浅拷贝） 此时需要自定义拷贝构造函数来实现深拷贝，为新对象分配原来指向的内容的新副本 d) 转换构造函数：只接受一个参数，即需要被转换的类型的参数 用于定义从其他类型到本类类型的隐式转换规则，如 MyString(const char* s) 建议使用时显式声明为 explicit，以防止隐式转换 7、强制类型转换 目的：提供比 C 语言风格的强制类型转换更安全的转换方式 a) static_cast：提供编译时能够确定的静态类型转换 b) dynamic_cast：提供运行时检查的动态类型转换，为多态类型服务 c) const_cast：用于添加或移除变量的 const 或 volatile 限定符的转换 d) reinterpret_cast：最底层的转换，不建议使用 8、new/delete 和 malloc/free 的区别 new/delete 在 执行 malloc/free 的基础上，还会再执行对象的构造函数进行初始化 如果 new 失败会自动执行 delete 回收内存 9、面向对象三大特性 封装：隐藏内部细节，暴露必要接口，类似于实现黑盒。有助于保护内部数据，同时降低耦合 多态：同一接口，多种反馈行为。有助于统一接口，同时提高灵活度 有两种多态类型： 静态多态: 即重载、运算符重载和模板 通过静态绑定实现，编译器根据签名在编译时决定调用哪个版本 动态多态: 即重写 通过动态绑定实现，编译器在运行时根据指向或引用对象的类型决定调用哪个版本 动态绑定的底层机制是虚函数表 vtable 和虚指针 vptr 继承：子类可以继承自父类的属性和方法。有助于代码复用和建立层次关系，也是实现多态的基础 10、虚函数相关 虚函数：用于制定规范，实现统一接口的函数，期待重写 虚函数表: 本质上是一个函数指针数组，存放虚函数地址。每个包含虚函数的类都有一个 虚函数指针: 每个包含虚函数的对象都有一个，指向其类的 vtable 动态绑定: 调用虚函数时，先通过 vptr 找到 vtable，再从 vtable 找到正确的函数地址执行 会带来额外的存储开销，和由于间接访问导致的时间开销 多重继承：形如 class C : public B1, public B2。即 C 从两个基类同时继承 C 里面有多个 vptr，对应各自基类的 vtable 重写的函数地址会在所有相关基类的 vtable 中被替换 如果不适用虚继承，则 C 的新虚函数通常追加到第一个基类的 vtable 部分末尾 菱形继承：如果 B1和 B2 继承自 A，那么 C 就会有两份基类 A 的成员，会导致冗余和二义性 解决方式：虚继承。也就是让 B1 和 B2 继承 A 时都使用 virtual 关键字声明 最终确保在派生类 D 的对象中，只包含一份共享的虚基类 A 的子成员 为什么析构函数要写成虚函数：防止资源泄露 只要你的类可能被继承，并且可能通过基类指针删除派生类对象 那么基类的析构函数就必须是 virtual 的，这能防止派生类额外申请的资源能被销毁掉 只要确保类不会被继承，就可以不加。但如果不是急切地需要节约开销，都建议加上 注意：析构函数的 override 行为与其他虚函数不同 它不是替换，而是在基类析构之前添加额外的清理步骤，使其按顺序逐步退化为它的基类 此时，vptr 指回基类的 vtable，再继续调用基类的析构函数 为什么构造函数不能是虚函数： 如果构造函数是虚函数，则派生类新对象创建时，就要选择合适的构造函数 但是，因为 vptr 在构造函数运行时才设置且正确赋值，所以无法指向正确的 vtable 而且，构造函数是建立完全已知的对象，而虚函数是根据运行情况再决定，两者目的相悖 为什么构造函数和析构函数不能调用虚函数：因为派生类对象不完整 因为如果调用了的话，由于对象不完整，vptr仍然指向基类，虚函数选择的版本会是基类的 在构造期间，由于派生类的成员尚未初始化，如果该虚函数需要访问派生类的成员或状态 就会导致未定义的操作发生（如果不需要访问，则能规避。但不推荐） 在析构期间，由于派生类的成员已经销毁，如果该虚函数需要访问派生类的成员或状态 同样会导致未定义的操作发生 纯虚函数： 是什么：用virtual关键字进行了声明，但是没有函数体，且函数声明末尾加 = 0; 形如：virtual double calculateArea() const = 0; 作用：使拥有纯虚函数的类变成抽象类，它不能实例化，只能被继承 继承的子类必须重写完所有继承的抽象类内的所有纯虚函数，才能变成具体类 形如：double calculateArea() const override &#123; return 3.14159 * radius * radius; &#125; 11、构造函数和析构函数相关 构造函数的执行顺序（逐步进化）： 如果有虚继承，最远的那个 virtual 最先被构造 (只构造一次) 然后，按照继承列表中的声明顺序依次构造 接着，按照在类中声明的顺序，依次构造自己的成员 最后，执行派生类自己的构造函数体（例如赋值） 析构函数的作用顺序（逐步退化）：跟构造函数执行顺序刚好完全相反 析构函数的作用时机： a) 当栈对象离开局部作用域范围时，例如函数结束 b) 当堆对象被delete时 c) 临时对象销毁时，例如由于函数返回或类型转换生成的 d) static 对象或全局对象，在程序结束时 构造函数的与异常： 如果构造函数抛出异常，则该类的析构函数不会被调用，这可能导致资源泄露 因此，应当把动态资源的管理封装为智能指针/其他类对象，并成为类的成员 析构函数与异常： 析构函数不应当抛出异常，否则可能会导致程序执行 terminate() 立即终止 析构函数内部应当使用 try...catch(...) 处理所有可能的异常，阻止其传播 C++11 起，析构函数默认是 noexcept(true)，向编译器承诺该函数不会抛出异常 12、内存泄漏 怎么看：任务管理器，top指令，Valgrind，Visual Studio内置的内存诊断 怎么避免：智能指针，将管理动态内存的逻辑封装在类中，使用STL容器 13、类的访问控制 类成员权限: public (定义类的公共接口) protected (允许派生类访问基类的实现细节，但对外部隐藏) private (封装类的内部实现细节) 继承方式: class Derived : [方式] Base 继承时，取继承方式和基类成员自身权限的更小者 例如，自身权限为 public，继承方式为 private，则最终权限为 private 14、类的组合 定义：一个类将其他类的对象作为自己的数据成员 相比于继承 &quot;is-a&quot; 关系，组合是 &quot;has-a&quot; 关系。其耦合度比继承更低，更灵活","tags":["Cpp"]},{"title":"C陷阱与缺陷 学习笔记","path":"/2025/04/05/C陷阱与缺陷 & C专家编程学习笔记/","content":"1. 词法陷阱1、判断时可以将判断值放前面，避免运算符&#39;==&#39;写错，如 NULL == p 2、用单引号括起的字符本质上是一个数。用双引号括起的字符串本质上是一个指针 3、短路求值：由于运算优先级的缘故，某些情况下，后面的运算不会进行 例如：v = a &amp;&amp; b++，当 a = 0的时候，b将不会自增 4、不要因为尝试对齐，而为十进制书面值添加0，这会让它们变成八进制表示 5、字符串默认以&#39;\\0&#39;结尾（在内存中表示为00） 所以具有n个字符的字符串，实际上空间占用为n+1，但有效长度为n 因此分配空间时，总是为字符串多预留一个空间 6、相邻的字符串常量会被自动合并成一个字符串 这意味着如果漏掉两个字符串间的逗号，编译器会合并两个字符串，导致逻辑错误 例如：available_resource[2] 会变成 &quot;Crayon-line drawing routines&quot; char *available_resouces[] = &#123; &quot;color monitor&quot;, &quot;big disk&quot;, &quot;Cray&quot; /*哇！少了个逗号。 &quot;on-line drawing routhines&quot;, &quot;mouse&quot;, &quot;keyboard&quot;, &quot;power cables&quot; &#125;; 2. 语法陷阱1、如果想把声明变成强制转换，需要按以下方式进行封装 A. 去掉所有的变量名 B. 去掉所有的分号 C. 将整体用括号括起来 例如：void (*p_func)(int) 可变成 (void (*)(int)) 2、即使函数调用时，该函数没有参数，也应该带括号 不带括号的也是一个函数调用语句，但只是计算该函数的地址而不调用 3、else会与最近的、未配对的if相匹配，所以不要偷懒不写花括号 4、C语言声明的优先级： A 声明中被括号括起来的那部分 B 后缀表达式，如 () 表示函数，[] 表示数组 C 前缀操作符，如 * 表示指针 如果处理上述优先级时，遇到const或volatile关键字 若后跟类型说明符（如int, long）时，作用于类型说明符 其他情况下，作用于它左边紧邻的指针 * 号 总的来说：从内到外，从右到左（但后缀优先） 例如：char * const *(*next)(); A 声明了一个名为 next 的变量 B 它是一个函数指针，指向一个无参数 C 返回值为常量指针 D 该常量指针指向一个 char 的指针 3. 语义陷阱1、C语言原生支持一维数组。多维数组本质上是数组的数组。 在 C89/90 标准中，数组的大小必须在编译时就作为一个常数确定下来 C99 引入了变长数组 (VLA)，允许在运行时确定数组大小 2、对于数组（在其定义的作用域内），可以做以下主要事情 使用 sizeof 运算符确定其总字节大小 通过下标 [] 访问其任意元素 在大多数表达式中，数组名会隐式转换为指向其第一个元素的指针 3、每次使用malloc时，最好用判断语句来判断其是否分配成功 4、为局部变量显式地分配内存时，应当在离开局部域时为其显式的释放，避免内存泄漏 5、直接使用数组名，在大多数表达式中会退化成指向数组首元素的指针 因此，不能直接将一个字符串常量赋值给字符数组，因为前者是地址 6、指针只保存地址。因此复制指针只会使两个指针指向同一块内存区域 7、main函数也具有返回值。如果不为其声明返回类型，则默认返回类型为整型 返回值为0代表成功，返回值为非0代表执行不成功 为了避免不必要的麻烦，建议显式地为main函数return 0 8、局部变量的生命周期仅限于所在块，这可能会导致返回结果错误 是否可以安全地返回局部变量取决于要返回的是值还是指针 如果是指针，则return时内存已释放，导致返回的指针可能成为悬空指针 例如：返回的类型与函数的类型不符，编译器会返回其地址，造成数据损坏 char * localized_time(char * filename) &#123; char buffer[120]; /* 代码片段 */ return buffer; &#125; 4. 链接1、可执行程序的生成过程分为以下几步： A. 预处理处理：检查和展开头文件，进行宏文本替换 B. 编译：进行语法检查，并将源文件中的高级语言描述转换为汇编 C. 汇编：将汇编转为二进制机器码，为每个源文件生成对应的目标文件 如果编译器开启了优化选项，则目标文件的代码还会经过优化器处理 D. 链接：将多个目标文件整合为一个可执行程序 2、extern 关键字：用于显式地说明对应变量的存储空间已经在其他地方进行了分配 告诉编译器，不要为它分配存储空间。链接器会自行找到其实际定义 如果在代码块里使用，则它将引用一个全局变量而非块外已定义的同名局部变量 例如：int my_var = 10; void func() &#123; int my_var = 20; printf(&quot;Local my_var: %d &quot;, my_var); &#123; extern int my_var; printf(&quot;via extern: %d &quot;, my_var); &#125; printf(&quot;inner block: %d &quot;, my_var); &#125; 3、static 关键字：用于显式地修饰某个变量或某个函数的定义域为当前源文件 用于文件作用域的变量或函数时：将其链接属性修改为内部链接 用于块作用域（函数内部）的变量时：修改其存储期为静态存储期（只初始化一次） 4、const 并不真正表示一个常量，而只是表示只读 const 修饰的变量不能用于需要编译时常量的场合 例如：const int two = 2; case two: printf(&quot;case 2 &quot;) 其有用之处在于保证函数不会修改实参指针所指的数据 5、动态链接库和静态链接库 静态库文件：本质上是多个目标文件的归档 链接时，将需要的部分抽出来，以静态链接方式合并到可执行文件中 动态库文件：本质上是可执行代码和数据的集合，被设计为在运行时被多个程序共享加载和使用 链接时，只检查该动态库是否存在。运行时，依赖操作系统查找并加载需要的部分到内存中 5. 库函数1、getchar函数会返回int，如果用char去接，那么超出-128-127的数值将会导致未定义行为 2、setbuffer：用于将写入到stdout的内容转移到指定的buffer，直到其填满或被手动flush为止 如果该函数在局部区域内使用，应确保其在离开域前，不被提前释放 3、errno：一个外部变量，用于取得库函数执行失败时的返回值 errno的值可能是其他库函数执行失败的结果 确保当前库函数提供了错误码且出错时，再去取得它的值做检测 4、fread 和 fwrite 会自动更新文件指针。所以不需要在连续的读或连续的写之间调用 fseek 6. 预处理器1、宏定义不会像函数调用那样带来开销，所以可以用于替换一些频繁而简单的操作，例如getchar 2、要清楚地认识到，宏定义只是文本替换，因此其内部的运算符号优先级不会因此提前 每次进行宏定义时，应当把每个参数，整个结果表达式都用括号括起来 3、在宏定义时，内部若出现++、--等自增自减符号，一般都会出现副作用，即他们可能执行两次 例如：biggest = ((biggest)) &gt; (x[i++])) ? (biggest) : (x[i++])); 4、宏定义并不是类型定义，应该使用typedef而不是#define来进行声明 7. 可移植性缺陷1、如果c是一个char，使用unsigned修饰并不会转换为等价的无符号整数，因为它将首先被转为int 正确的方法是不要偷懒，用 unsigned char 去修饰 2、右移比除法的运算速度要更快，不过如果被除数为负数则可能不适用 8. 数组1、指针和数组使用的是一套硬件机制，即偏移量和指针，但是两者并不完全等价 2、如果有int a[10], *p, i=2; 则访问 a[i] 的方式可以为： A. 首地址方式： p=a; a[i] 或 i[a] B. 先偏移再取址：p=a; *(p+i) C. 先取址再偏移：p=a+i; *(p) 3、实参：调用函数时传递给函数的值；形参：函数定义或声明原型中使用的变量 数组形参在编译时只取首地址的指针，从而节约时间和空间 因此在函数内对其sizeof将会导致结果不正确 4、多维数组作为形参，声明时必须提供除了最左边一维以外的所有维长度 例如：int a[2][3][4]，可以写为 int a[][3][4] 5、C语言的数组在内存中为一维排布，所以总是最右边的下标先变化 6、指针数组只能由单独数组的形式初始化 例如：int r1[] = &#123;1, 2&#125;; int r2[] = &#123;3, 4&#125; int *p[] = &#123;r1, r2&#125;","tags":["C"]},{"title":"C与指针 学习笔记","path":"/2025/03/19/C与指针学习笔记/","content":"1. 基本概念1、指针的优势：对底层内存几乎无限制的访问，且可以直接在上面做数据修改 这种方式速度快，且操作自由。但也需要程序员自行实现安全的访问和操作 2. 数据1、基本数据类型：整型、浮点型、指针和聚合类型（如数组或struct） 2、长整型至少和整型一样长，整型至少和短整型一样长 标准并没有规定长整型一定要比短整型长，只是规定它不得比短整型短 short int至少16位，long int至少32位，至于int的长度则由编译器设计者决定 各种整型的长度，可以通过观察编译器自带的头文件limit.h来决定 3、只有程序使用的char变量的值处于signed char和unsigned char的交集，它才是可移植的 确保char被显式声明为signed 或 unsigned时，才对其执行算术运算，避免未定义行为发生 4、字面值：即编译时的常量，如数组的大小，赋值时的右值。预处理阶段不会为其分配内存 在字面值后添加字符，便于将其解释为特定类型的值，例如L解释为long，U解释为unsigned 在缺省情况下，字面值的类型是足以容纳它的值且空间占用最小的类型 5、字符常量：用 &#39;&#39; 括起来的单个字符，或字符转义序列（如 ）或三字母词 字符常量的类型总是为int，不能在后面添加U或L后缀 6、使用1.0、2.0等书面值进行赋值时，默认属性为double 如果需要使用float，应当在后面加上一个后缀F 7、描述指针的*号应该写在变量一侧，以防声明时混淆 例如：int* a, b; 实际上只有 a 是 int 指针，b 只是 int 8、以const关键字修饰的变量只能在声明时初始化 在函数中声明为const的形参会在函数被调用时得到实参的值 9、多次使用static或extern关键字修改作用域时，仅以第一次修改为准 10、register用于自动变量的声明，编译器会将它们存放于寄存器而不是内存 现代编译器在寄存器分配方面做得比手动指定好得多，因此该该声明已经过时 它唯一剩下的强制作用是：不能对声明为 register 的变量取地址 3. 循环1、如果需要至少执行一次循环，则选择do ... while ... 2、每个case标签必须具有一个唯一的值，它不是字面值，而是一个常量表达式 3、只有一种情况下建议使用goto，那就是需要立即跳出多层嵌套的循环时 也可以改写为以下形式：进入循环时判断状态标志，以此决定是否退出 例如：status = OK; while(status == OK &amp;&amp; condition1) &#123; while(status == OK &amp;&amp; condition2) &#123; while(condition3) &#123; Status = EXIT; break; &#125; &#125; &#125; 也可以将多层嵌套循环放进一个函数，函数执行到return时会整个退出 4. 操作符1、对于有符号数，移位操作是采取逻辑移位还是算术移位取决于编译器，且会影响可移植性 2、sizeof可以对表达式求值，只需要将其用括号括起来即可 sizeof判断大小并不需要求解表达式，例如sizeof(a=b+1)并没有进行赋值操作 3、C99引入了_Bool类型和&lt;stdbool.h&gt;头文件，使用bool类型时应当引用该头文件 4、逗号操作符可以将一个或多个表达式分割开来，整个表达式的值是最后那个表达式的值 例如：if(b + 1, c / 2, d &gt; 0)，只会判断最后一个表达式的大小 前面的表达式执行了但只是执行结果被丢弃，因此可用于赋值等操作 5. 指针1、通过一个指针访问其所指向的地址，并查看那里的值的过程，称为间接访问或解引用指针 2、要使一个指针变为NULL指针，可以为其赋0值，这是约定俗成的 3、强制类型转换可以将一个int转为指向int的指针 例如*(int*) 100，则这一间接访问就是合法的 这种写法仅在需要访问内存中某个特定位置时有用。对于普通应用程序开发应绝对避免 4、当一个特定类型的指针与整数量执行运算时，会根据指针类型自动调整增加的大小 例如：指向float的指针p+1，则偏移量为1个float的大小 5、两个指针相减的值是它们在内存中的距离，是有符号整数类型 以数组元素的长度为单位，而不是字节为单位。因为运算结果会除以数组元素的大小 6、在指针中使用自增或自减操作符仍然会导致副作用，例如 A. 对于*vp++ = 0，其执行步骤为： 先拷贝vp当前值，将vp进行解引用，然后赋0值 再在拷贝值上进行vp = vp + 1 的副作用赋值，随后将值赋回给vp B. 对于*++vp = 0，其执行步骤为： vp = vp + 1 直接在vp上执行，不进行拷贝 对vp进行解引用，然后赋0值 6. 函数1、一组被用到的函数应被放在某个源文件中，然后设计一个同名的头文件放其函数原型 使用时，在main函数所在的源文件引用该头文件 2、尾递归：相比原始递归，它会将它的结果作为形参直接传给下一个递归 这样做可以不必再在计算时展开该函数本身，从而在计算完成后就终结其生命周期 例如：int fun(int n, int res) &#123; if (n == 1) &#123; return n; &#125; return fun(n - 1, sum + n); //而不是 return n + fun(n - 1); &#125; 现代编译器在开启O2/O3编译时可能会尝试尾递归优化 3、可变参数列表定义于stdarg.h头文件，用于处理未知个数的形参 参数列表中的省略号提示可能的多个可变参数，如：int fun(int n_values, ...) 需要通过va_start函数向va_list类型的var_arg读入这些可变参数 例如：va_start(var_arg, n_values)，n_values用于指示开始读取的位置 访问完最后一个可变参数时，调用va_end(var_arg) 7. 指针1、如果用指针p指向一个数组，则p[0]是一个合法的表达式 2、声明一个数组时，编译器根据元素数量为数组保留内存空间，然后再创建数组名 数组名的值是一个常量，指向这段空间的起始位置 3、数组的传值调用虽然传的是指针，但也只是copy了一份该指针的值再调用 所以数组内下标操作不会影响到原来数组的首地址 这也和“所有参数都是以传值方式传递”的结论相符合 4、每次进入函数后的初始化具有一定代价，如果不需要该变量的值更改，可以转为static 5、如果要创建多维数组的指针，则除第一维度外，后面的维度都要包含且匹配 例如：为三维数组a[2][3][4]创建指针，则其指针形式应为 (*p)[3][4] 如果要让多维数组的指针在与整数运算时，不是一行一行变换，而是一个元素一个元素地变换，则该多维数组的指针应当特别地指向该数组的首个元素 8. 字符串、字符和字节1、strlen返回的是一个类型为size_t（无符号整数）的值，将其参与表达式运算要小心 如果一定要做运算，则应当先将其转为int类型 2、如果使用strcpy，而不是strncpy，则应当保证目标字符数组的空间足以容纳需要复制的字符串 否则，溢出的字符将覆盖原先存储于数组后面的内存空间的值 如果使用strncpy，指定长度为n，而目标数组空间大于n，则将使用额外的\\0字节填充到n 如果目标数组空间小于n，则只会把前n个字符复制，而且不会添加\\0字符！ 3、用strcmp比较字符串时，如果两个字符串相等，则返回值为0，且没有规定不相等时的返回值 4、在一个字符串中查找特定字符时，可以使用strchr和strrchr 前者是从左往右，找到第一次出现的位置，然后返回指向该位置的指针，后者是从右往左 如果找不到，就会返回NULL指针 5、使用strpbrk函数查找字符串中任何一组字符第一次出现的位置，和strchr的返回方式一样 6、字串查找可以使用strstr函数。和strchr的返回方式一样 7、strspn用于从字符串的起始位置开始，根据group的匹配程度对字符计数 当遇到不属于group的字符时，立刻返回计数值 strcspn用于取反计数，也就是只计数那些不在group中的字符 8、strtok通过指定分隔符参数，依据分隔符把字符串分割为多个token 例如：strtok(char *str, char const *delim)，每次返回一个指向找到的token的指针 注意：strtok会修改它所处理的字符串！ 同时，由于strtok依赖当前的字符串状态进行处理，所以不能交错调用strtok（不可重入） 9、memcpy用于从src赋值len个字节到dst的位置，可以复制任意内容，但要注意重叠的可能 如果有重叠现象，建议使用memmove 9. 结构和联合1、即使结构成员函数完全相同，只要不显式声明结构的名称（标签名），都会被视为不同的结构 这会导致对应的声明所属类型完全不同 要创建可以在不同变量和函数间共享和兼容的结构类型，必须使用标签名或typedef 2、-&gt;箭头操作符的左侧必须是指向结构的指针，其运算优先级与点操作符相同 3、如果在结构内部包含一个类型为该结构本身的成员，则此定义非法 如果包含的是该结构类型的指针，则合法。这也是链表和树等高级数据结构的构造方式 4、如果每个结构都在成员中使用了对方结构的标签，则应当使用不完整声明 例如，如果结构A和B相互引用，则应当简略声明struct B，然后再详细定义A和B 5、系统禁止编译器在结构的起始位置跳过字节来满足成员的对齐要求，但末尾可以填充 因此，所有结构的起始存储位置必须是结构中边界要求最严格的数据类型的存放位置 一般来说，小的成员放前面，大的成员放后面，可以最大限度减少由于边界对齐导致的空间损失 6、使用位段时，最好使用signed或unsigned显式地声明 如果声明为int，则其到底为有符号数还是无符号数由编译器决定 7、union的所有成员使用同一个内存位置，因此适用于存储同一时间互斥的变量 union的长度取决于最长的成员的长度 因此如果它们的长度悬殊，则应当存储指向不同成员的指针，避免内存浪费 当存储的是指针时，通过动态内存分配，可以在决定使用该成员时才分配内存来存储它 如果要初始化union，能且只能初始化为第一个成员类型的值，且必须位于花括号中 使用C99的指定初始化器，则可以初始化任意成员。如 union U u = &#123; .m2 = &#39;a&#39; &#125;; 10. 动态内存分配1、calloc和malloc的区别： calloc会在分配内存，返回指针前将其初始化为0。malloc和relloc都不会 calloc通过参数中给出的所需元素个数和每个字节的元素数自动计算分配的内存 2、如果原先的内存大小无法更改，则relloc将分配新大小的内存，并把数据复制过去 此时应当使用relloc返回的新的指针调用该区域，同时旧指针不应再使用 因此使用free销毁内存区域时，应当检查先前的函数是否执行成功 3、每次使用malloc时，应当检查返回的指针是否为NULL，避免未定义操作 4、使用sizeof而不是固定数值来创建内存区域，从而提高程序的可移植性 11. 高级指针话题1、函数无法直接访问其作用域外的变量名，可以通过传递其指针来实现间接访问，以修改它的值 2、函数指针的常见使用场景 回调函数：一个作为参数传递给其他函数，并在将来某个特定时机被那个函数回头调用的函数 函数在执行过程中，可以在某个特定时机通过接收到的函数指针来调用特定函数 可用于实现异步操作，以避免需求时间过长的函数卡住主程序 或者，设计一个通用流程函数，而执行特定工作时由客户提供的回调函数解决 跳转表：将不同操作的函数的指针存放在数组中，从而在某些情况下直接访问数组并调用该函数 可用来替代冗长的 if-else 或 switch-case 语句，且效率可能更高 使用跳转表之前，需要对每一个函数先给出它的原型定义！ 例如：result = opfer[index](op1, op2); 3、main函数通过 argc 和 argv 来接受和处理命令行参数，它是可选提供的，可以不显式声明 argc 是一个整数，用于计数参数的数量 argv 是指向一个序列的字符型指针，每个指针指向一个命令行参数，序列以NULL结尾 4、字符串常量实际上是一个指针，所以对其做整数运算等于移动下标 对其做间接访问运算，将得到它的第一个元素 5、无论任何类型的指针，总是应当先初始化，再使用。如果没有值，应总是设为NULL 12. 预处理器1、#define 允许把参数替换到文本中，这被称为宏或定义宏。宏不可以递归 宏与类型无关，而且宏的参数还可以是一种类型（如int）。这意味着它比函数更泛用 使用宏就会进行文本替换，所以可能会显著增加代码的长度 2、#undef 用于移除一个现存的宏定义 3、#if defined(...) 等价于 #ifdef ...，都用于条件编译中，#if能执行更加复杂的判断 同理，#if !defined(...) 等价于 #ifndef ... 4、应当尽量避免#include时的多重包含，也就是说要防止一个头文件在一个编译单元中被包含多次 可以通过包含卫哨来解决，形如： #ifndef MY_HEADER_H_ // 1. 检查 MY_HEADER_H_ 这个宏是否未被定义过 #define MY_HEADER_H_ // 2. 如果上面检查结果为真 (即第一次包含)，就定义宏 // 这里是头文件的实际内容 #endif MY_HEADER_H_ // 3. 结束 #ifndef 的条件块 或者在头文件中包含 #pragma once 指令，既可以保证编译器只会包含和处理该头文件一次 5、#error 指令允许生成错误信息 6、#line 指令将根据输入的参数，分别修改行号和文件名（可选），例如#line num &quot;string&quot; 13. 输入输出函数1、file* 代表指向file结构体的指针，该结构体是标准库用于抽象表示输入输出流的数据类型 为了对文件执行流I/O操作，必须先使用fopen函数打开，其返回一个file*类型的指针 注意检查fopen函数的返回值 2、exit函数用于终止程序的执行，并返回其参数status作为状态值 perror函数用于给出一个错误信息。一般与exit函数连用 3、由于printf是先把内容放到缓冲区再输出到屏幕的，所以可能在某些情况下不能立即输出 例如，如果没有换行符 ，则可能会等待到缓冲区满，printf才输出 因此如果要将printf用于调试输出，则应当在后面使用fflush(stdout) 4、fprintf 是 printf 的上位替代，适用于所有流 后者只适用于标准输入输出。前者还可以输出到stderror或文件中去 类似的还有 scanf 和 fscanf，getchar 和 fgetc，puts 和 fputs fgets 已经代替了因为缓冲区问题而不安全的 gets 5、ftell函数返回当前在流中的位置，也就是距离流起始位置的偏移量 6、fseek函数允许在一个流中，根据输入的offset改变当前读取或写入操作的位置 改变位置将丢弃任何被退回到流的字符（ungetc） 7、tmpfile函数用于创建一个临时文件，remove函数用于删除一个指定的文件 8、sscanf函数用于从内存中的一个字符串中读取格式化的数据 9、sprintf函数用于将格式化的数据写入到内存中的一个字符串（字符数组）中 推荐使用更安全的 snprintf 替代，它会额外接受一个缓冲区大小参数 14. 标准函数库1、stdlib.h atoi(), atol(), atoll(): 将字符串转换为整数，基数为10 atof(): 将字符串转换为 double strtol(), strtoul(), strtoll(), strtoull(): 字符串转整数函数，可指定基数 rand(): 生成一个伪随机整数 srand(): 为 rand() 函数设置种子，通常用当前时间 time(NULL) 来初始化 abort(): 异常终止程序执行，通常表示发生了严重错误 确保只在主流程函数中使用abort和exit atexit(): 注册一个在程序正常退出时会被调用的函数 注意：不要在注册为退出函数的函数中使用exit，以避免无限调用 qsort(): 对数组进行快速排序（需要提供一个比较函数） bsearch(): 在已排序的数组中执行二分查找 2、math.h 在未引用math.h时使用数学函数的行为是未定义的 ceil()、floor()、round()、trunc()：向上取整、向下取整、四舍五入、向零截断 INFINITY：表示正无穷大 NAN: 表示 &quot;Not a Number&quot; 3、time.h struct tm: 一个结构体，用于存储分解后的时间和日期信息 月份下标从0开始，年是从1900年开始计数的 size_t: 无符号整数类型 time(): 获取当前的日历时间 clock(): 返回程序启动以来所消耗的处理器时间（近似值） ctime(): 将 time_t 类型的时间转换为本地时间的字符串格式 gmtime(): 将 time_t 转换为 UTC 的 struct tm 结构体 strftime(): 根据 format 中指定的格式，将 tm 格式化为字符串，存入目标字符数组 difftime(): 计算两个 time_t 时间之间的差值（以秒为单位，返回 double） 4、assert.h assert：是一个宏而非函数。断言括号内的表达式应为真，如果不是则发出诊断信息并终止程序 通过向编译器添加-NDEBUG来丢弃断言 也可以在源文件里assert.h被包含之前，添加#define NDEBUG来丢弃 15. 经典抽象数据类型1、assert主要用于调试阶段，在发布Release版本的程序中，assert会被编译器优化掉 因此，仅仅使用assert检查内存是否分配成功是危险的 但除此之外，assert是帮助检查程序运行时假设的好工具 2、在C语言中创建泛型ADT的两种常见方法：宏和 void*（通用指针） 通用指针原理：利用 void* 可指向任何类型对象的特性，在ADT内部只存储指向实际数据的指针 此时，ADT 的操作函数都接收或返回 void* 类型的参数 使用 void* 来实现泛型函数或数据结构时，编译器无法检查类型是否正确 同时，由于ADT数据项的分散性，需要用户或ADT自己实现动态内存分配和释放 宏原理：编写一套模板代码，这套代码中会使用宏参数来代表具体的数据类型和函数/结构名称 每实例化一种类型，就会生成一套完整的ADT代码副本，导致最终的可执行文件体积增大 需要设计良好的命名约定（如使用前缀/后缀）来避免不同类型实例化的函数和结构名冲突","tags":["C"]},{"title":"Linux命令行与Shell编程学习笔记","path":"/2025/01/20/Linux命令行与Shell编程学习笔记/","content":"1. 什么是shell1、提示符中的符号 # 代表以超级用户权限执行，$ 代表以普通用户权限执行 2、系统后台持续运行中的虚拟终端可以通过按下 Ctrl-Alt-F1 到 Ctrl-Alt-F6 访问 2. 文件系统跳转1、pwd ：打印工作目录 2、ls ：列出工作目录下的文件与目录 参数为多个路径时，即可同时列出多个路径下的文件 -a ：列出所有文件，包括以&quot;.&quot;字符为名称开头的隐藏文件 -l ：仅显示当前目录下所有内容的详细信息 -d ：仅显示当前目录的详细信息 -t ：以修改时间来排序 -S ：以空间占用大小来排序 -r ：以降序显示结果（字母/时间/大小） -h ：以人类认知的单位为格式显示大小，而不是以字节数 -F ：输出时指示类型 / 代表目录 @ 代表符号链接 * 代表可执行文件 = 代表套接字 | 代表管道 没有后缀 代表是一个普通文件 3、cd ：跳转到指定目录 cd - 代表跳转到上一个cd的目录 4、绝对路径：以 / 依次表示的树形路径 5、相对路径：用 . 代表当前目录，用 .. 代表父目录 3. 探究操作系统1、file ：打印出文件的描述信息 2、less ：一个页面查看器，用于只读地查看文本内容 由于是分页加载到内存的，所以大文件阅读有优势 3、常见文件路径： /bin 或 /usr/bin ：存放由系统自带的用户权限程序 /sbin 或 /usr/sbin ：存放由系统自带的超级用户权限程序 /boot ：存放系统启动时的加载程序，以及Linux内核 /dev ：设备结点目录 /etc ：存放系统配置文件，以及开启系统服务的shell脚本 /lib 或 /usr/lib ：存放安装的所有程序运行和编译时共享的动态链接库文件 /lost+found ：文件系统恢复目录 /media ：可移动介质挂载目录 /proc ：内核维护的虚拟文件系统，用于读取系统状态 /usr/local ：存放非系统自带的程序的数据 由源码编译的程序安装在其中的bin文件夹 头文件安装在其中的include文件夹 /usr/share ：存放系统安装的所有程序运行时共享的静态数据，如doc文件夹下的帮助文档 /var ：存放程序运行时的各种动态文件，如数据库，日志文件等 4. 操作文件和目录1、常见通配符： * 用于匹配任意个字符（可以是0个或1个） ? 用于匹配任意一个字符 [] 用于匹配用户指定的字符集中的任意一个字符，如[abc] [!] 用于匹配不是用户指定的字符集中的任意一个字符，如[!abc] [[:XXX:]] 用于匹配系统指定的字符集中的任意一个字符 可以和用户指定的连用。如：[[:alnum:]]、[[:lower:]123] 常用的字符集： alnum(字母+数字) alpha(字母) digit(数字) punct(标点符号) lower(小写字母) upper(大写字母) 2、mkdir ：创建目录 后面跟多少个argument，就会在当前工作目录创建多少个目录 3、cp ：复制文件内容（例如文本）/目录到指定的文件/目录中 可以跟多个argument，会把前几个argument的内容复制到末尾argument指定的文件/目录中去 -a ：带属性复制 -i ：交互式复制 -r ：递归复制 -u ：只复制目标目录中不存在的文件，或对目标目录中已存在但是更旧的文件进行覆写 -v ：显示复制过程的操作信息 4、mv ：移动文件。其argument与option的引用方式和cp一样 当目标argument不存在时，会按照源argument进行隐含类型创建 5、rm ：删除文件。可以跟多个argument 也使用和cp一样的 -v/-i/-r 选项 -f ：强制执行，此时会忽略 -i 6、ln ：创建硬链接或符号链接 创建硬链接：形如：ln file link 创建符号链接，形如：ln -s item link 5. 使用命令1、命令可以是以下五种形式之一： bin路径下存储的二进制程序 ruby等脚本语言写成的程序 shell内建命令 由alias指定的别名 shell会话函数（会话关闭时消失） 2、type ：显示命令的类型，如：是哪个二进制程序、是否为内建命令、是否为别名 3、which ：找到命令依赖的可执行程序的路径，对内建命令无效 4、help ：给出内建命令的帮助文档 5、man ：给出命令的程序手册 man 数字 &lt;命令&gt; ：代表查看程序手册的第几节 -k ：用于通过搜索程序手册的关键词，显示适当的命令 6、程序自带的README存储在/usr/share/doc下，可通过less或zless（如果文档压缩为gzip）查阅 7、alias 用于给指定的命令序列创建别名 语法：alias &lt;别名&gt; = &#39;&lt;命令序列，中间用分号隔开&gt;&#39; 可通过 unalias 删除已设置的别名 定义的别名会随着会话结束而消失 如果不加任何参数，则代表查阅已创建的别名 6. 重定向1、输出重定向 &#39;&gt;&#39; ：把输出信息写入到文件。每次使用时会导致内容覆写。如果文件不存在则会自动创建 如果不想要输出，可以将其输出到/dev/null &#39;&gt;&gt;&#39; ：在已有文件内容后进行追加。如果文件不存在则会自动创建 &#39;数字&gt;&#39; ：指定类型的重定向。0、1、2分别代表标准输入、输出、错误 &#39;&amp;&gt;&#39; ：联合重定向。例如可以将标准输出和错误一起重定向到文件中去 2、cat ：将一个或多个文件连接为一个文件（指定输出时），或一起显示在屏幕上（未指定输出时） 不加任何argument时，cat会等待用户的标准输入。此时输入ctrl-d代表到达EOF -A ：显示控制字符 -n ：显示行号 -s ：禁止输出多个空白行 3、管道符号&quot;|&quot; ：将一个命令的输出作为另一个命令的输入 &quot;|&quot;后可以加关键词，称为过滤器，它能实现对输入的数据进行预处理，再传输给下个命令 过滤器本身就是可单独执行的指令，常见的过滤器如下： tr（字符的查找和替换操作） tr &lt;arg1&gt; &lt;arg2&gt; ：用字符范围arg2取代字符范围1，可以是字符类、字符域、列表 -s ：挤压，即删除相邻的重复字符，只保留一个 sort (排序) -b ：从第一个非空白字符开始，对整行进行排序 -f ：排序不区分大小写 -n ：基于字符串的数值来排序 -m ：只执行合并，不执行排序 -r ：反向排序 -o ：指定输出文件，而不是标准输出 -k &lt;num1&gt;.&lt;num2&gt; ：指定第num1个字段，偏移&lt;num2&gt;个字符为排序标准 uniq (去重) -f &lt;num&gt; ：开头的num个字段不作为去重标准 -s &lt;num&gt; ：开头的num个字符不作为去重标准 -i ：忽略大小写 -d ：反向去重 -c ：反向去重，并且每行开头显示重复的次数 wc (字数统计)：会输出行数、单词数和字节数 -l ：只输出行数 grep (正则匹配) -i ：匹配忽略大小写 -v ：反向匹配 -c ：打印匹配数量 -l ：只打印包含匹配项的文件名 head/tail（打印头和尾的行） 默认10行，可以用-n &lt;num&gt; 指定打印行数 -f ：持续监测末尾行的变化情况，并在屏幕上实时输出 tee (数据捕捉): 对结果不做任何处理，只是复制到指定文件，内容可流动到下一个管道中 形如：ls /usr/bin | tee ls.txt | grep zip 7. 从shell眼中看世界1、echo ：打印argument 2、常见的argument展开类型： 路径名展开：使用通配符进行匹配，例如ls \\usr\\*\\bin 波浪线展开：例如使用cd时，跟一个~（但不加用户名），那么cd会指向当前使用者的家目录 算术表达式展开：指的是$((expression))中，expression的算术表达式可以被计算 花括号展开：利用花括号内表达式创建多个文本字符串，例如echo Front-&#123;A,B,C&#125;-Back 表达式可以是一个整数区间，如&#123;1..5&#125;，倒序的字符区间&#123;Z..A&#125; 表达式还可以相互嵌套，如echo a&#123;A&#123;1,2&#125;,B&#123;3,4&#125;&#125;b 参数展开：将以$开头的变量的值进行输出 命令依赖：将命令的执行结果作为临时变量的值，然后再利用参数展开将其作为argument使用 如file $(ls /usr/bin/* | grep zip) 历史命令展开：以!开头。可将history命令搜寻的结果插入到命令行中 3、常见的argument引用类型： 双引号：用于防止因空格导致的argument单词分割，例如：ls -l &quot;two words.txt&quot; 在双引号中，除路径名展开外，所有类型的argument展开依然有效 单引号：双引号的加强版。会禁止内部的一切argument展开，如包含元字符的正则表达式 8. 键盘高级操作技巧1、history: 读取系统记录的，输入的最后500个命令 搜索得到的结果用行号区分，可直接用&#39;!&lt;数字&gt;&#39;的形式重复执行该命令 9. 权限1、文件属性：可以用-l 查看，共10个字符 第一个字符为文件类型，其中： - 代表普通文件 d 代表目录 l 代表符号链接。符号链接的文件属性总是为虚拟值rwxrwxrwx c 代表字符设备文件 b 代表块设备文件 剩余9个字符为文件模式，3个一组。代表文件所有者、文件组所有者、其他人的读写执行权限 r 允许打开并读取文件内容，或列出目录下的所有文件（当有x权限时） w 允许写入或截断文件，或在目录下新建、删除或重命名文件（当有x权限时） x 允许该文件被执行（若为脚本，还必须有r权限才可执行），或允许进入目录 2、chmod ：对于文件所有者或者超级用户，可通过执行此命令更改文件属性 语法：chmod &lt;权限及修改&gt; argument u代表user、g代表group、o代表other +代表增添、-代表删除、=代表设置 例如：u+x,go=rw 代表为拥有者增加可执行权限，为文件组用户和其他用户设定为读写权限 3、umask ：设置创建文件时的默认掩码值（以4个八进制数表示，如默认值0022） 语法：mask 0000 若无其他操作，设置的掩码只在本次shell会话中生效 4、sudo ：给予普通用户临时的超级用户权限以执行某些命令，要求该用户自己的密码验证 5、chown ：用于修改文件或目录的所有者或用户组，需要超级用户权限 语法：chown [owner]:[group] file 如果owner为空，组有设置，如:admins，则代表owner不变 如果owner不为空，组没有设置，如bob: 则代表将组设置为bob登录系统时所属的用户组 6、passwd 用于修改某个用户的密码 10. 进程1、ps 用于展示当前正在运行的进程 若执行ps x，则会额外增加一栏用于描述进程目前的状态 进程可能的状态如下： R 运行中，或准备运行 S 可中断睡眠 D 不可中断睡眠，通常是因为等待I/O T 已停止运行 Z 僵尸进程，通常是由于父进程未来得及清除已终止的子进程 &lt; 高优先级进程 N 低优先级进程（nice） 执行ps aux则会给出进程的硬件资源占用情况。如RSS（物理内存大小）和VSZ（虚拟内存大小） 2、top ：显示连续更新的系统进程列表 3、进程控制 ctrl-c 仅作用于前台进程：发送SIGINT，友好地请求进程终止执行（但可以被程序捕获并询问） ctrl-z 仅作用于前台进程：发送SIGTSTP，暂停进程执行 kill 对任意进程发送信号（不论是前台还是后台），可以用option来指定发送什么 语法：kill -option PID/jobspec -TERM 缺省值，强行终止进程，目标程序会接收到这个信号 -INT 类似于ctrl-c -KILL TERM的加强版，直接由内核杀死。目标程序不会接收到这个信号 -STOP 类似于ctrl-z -CONT 令进程从暂停状态中恢复 kill all 用于给匹配特定名称的多个进程发送信号 语法：killall [-u user] [-signal] name 一般加sudo使用，因为可能该进程归属于其他用户 命令后加&amp;，会令进程启动后立刻在后台执行，并返回jobspec和PID 使用fg/bg %jobspec，可令对应的进程返回前台/进入后台运行（foreground/background） 11. shell 环境1、shell中有两种数据类型: 环境变量和shell变量 printenv指令不带参数时，只会打印环境变量 set指令不带参数时，会将环境变量和shell变量都打印 由于环境变量列表比较长，所以输出时最好通过管道传递给less set命令和printenv命令都不能显示别名 2、重要的环境变量 PATH：等同于Windows的PATH TERM：指定终端所使用的协议类型 3、shell会话的两种类型:login shell和non-login shell 如果要添加PATH或定义额外的环境变量，则应该修改家目录下的.bash_profile 如果要添加别名或其他设置，则应该修改家目录下的.bashrc 使用source指令，在不重启bash的情况下重新读取配置文件，如source .bashrc 4、export：用于设置环境变量。例如在bashrc中修改代表提示符的PS1后，需要对其export 15. 存储媒介1、/etc/fstab 列出了系统启动时要挂载的设备（例如系统分区），典型字段如下： 设备名：包含与物理设备相关联的设备名，如/dev/hda1 挂载点：设备所连接到的文件系统树的目录 文件系统类型：如ext4，swap等 选项：挂载时的选项参数, 如只读 2、mount ：挂载设备到指定的文件系统上 不带参数时会调出目前已经挂载的文件系统列表 语法：设备 on 挂载点 type 文件系统类型 如果mount的路径参数为非空目录，则在unmount前无法查看该目录下原有的文件 3、unmont ：卸载设备 如果当前工作目录还在挂载点，则会导致卸载失败 卸载的目的在于让设备在退出前，将缓存安全地写入低速设备，防止数据丢失 4、设备命名模式 /dev/sd* ：SCSI磁盘 /dev/hd* ：IDE磁盘 /dev/lp* ：打印机 /dev/sr* ：光盘 使用字母对设备进行编号，例如第一通道的主从设备编号ab，第二通道的主从设备编号cd 使用数字对分区进行编号，例如第一分区编号1。没有数字时则代表整个磁盘 5、fdisk ：执行磁盘分区程序 6、mkfs ：创建文件系统，形如 mkfs -t &lt;文件系统类型&gt; &lt;设备名&gt; 7、fsck ：测试和修复文件系统，恢复的部分被放置于 lost+found 目录 8、dd ：以块模式将数据从一个设备复制到另一个设备/文件 复制为文件，形如：dd if=/dev/sdb of=flash_drive.img 复制到设备，形如：dd if=/dev/sdb of=/dev/sdc 16. 网络系统1、traceroute ：显示到达网址所需的路由器跳数 2、netstat ：查看系统网络信息 -ie ：查看网络接口。通常注意第二行的ip地址和第四行的单词UP，代表这个网络接口已经生效 -r ：显示内核的网络路由表 3、ftp：即文件传输协议，可使用lftp或基于ssh的sftp代替 4、wget：下载任意网络文件 5、ssh：用于连接远端SSH服务器，本质是建立了一条加密数据传输通道 语法： ssh &lt;远程主机名&gt; &lt;指令名&gt; ssh &lt;用户名&gt;@&lt;远程主机名&gt; &lt;指令名&gt;（如果已在主机上拥有用户） -X ：可以运行远程主机上的X Window并把图像化效果显示到本地 如果ssh命令没有成功验证远程主机，则可能是：中间人攻击、远程系统配置改变 后者只需要根据警告信息移除过时的offending key即可 6、scp：用于实现ssh下的安全复制 17. 查找文件1、locate : 通过文件名查找文件，会输出包含参数的路径名列表。可以使用管道进行正则搜索 locate依赖updatedb创建索引数据库，手动运行updatedb可以避免locate搜索不到的情况 -regex ：使用正则表达式进行匹配 2、find ：可以根据文件的各种属性在既定的目录及其子目录中查找 可以通过补充各种测试条件进行搜索 -type 代表按文件类型搜索，如l为符号链接，f为普通文件，d为目录 -name 代表按通配符模式进行搜索 -size 代表按大小进行搜索，如+1M代表大于1M的文件，-1M代表小于1M的文件 -empty 用于匹配空文件和目录 -inum 用于匹配inode号是n的文件。这对于找到某个inode的所有硬链接很有帮助 -newer 用于匹配内容修改日期晚于指定的文件的文件和目录 测试条件可以与逻辑符号连用，如-and、-or、-not和括号 由逻辑符号连接的表达式，越往前执行优先度更高（非常重要） 可以通过预定义操作对搜索结果进行处理 -delete 删除匹配的文件 -ls 执行结果等同于ls -d，结果发送到标准输出 -print 把匹配文件的全路径名输送到标准输出，这也是默认处理 -quit 一旦找到一个匹配就立即退出 可以通过-regex 选项使用正则表达式进行匹配 可以使用用户想要执行的操作命令代替预定义操作 语法：-exec &lt;指令&gt; &#39;&#123;&#125;&#39; &#39;;&#39; 如果用-ok来代替-exec，则每一次指定命令执行之前系统都会询问用户 如果&#39;;&#39;被替换为&#39;+&#39;，则不会每次匹配时执行指令，而是将结果作为一个整体执行 18. 归档和备份1、gzip：压缩一个或多个文件, 执行命令后原文件会被压缩文件取代，时间戳和权限保持不变 -d ：用于解压缩，还原原文件。等同于gunzip -f ：强制压缩，在压缩文件已存在时使用 -r ：递归压缩 -t ：测试压缩包 -v ：输出详细信息 -&lt;num&gt; ：代表压缩的等级，1代表最快压缩，9代表最大压缩 -c ：将输出重定向到标准输出，并且保留原始文件 2、tar：归档文件为一个大文件，不进行压缩 语法：tar [选项] &lt;目标tar文件路径&gt; &lt;源路径&gt; tar的选项不带&#39;-&#39;号，常用的选项如下 c 创建文件和/或目录列表的归档文件 f 指定归档文件名，一定会有。如果后面跟&#39;-&#39;，则代表不创建归档文件，定向至标准输出 x 从归档中提取文件 提取的文件属于执行复原操作的用户，除非以超级用户身份运行 如果在后面添加路径名，则代表只恢复该路径下的内容 t 列出归档文件的内容 r 在归档文件末尾追加指定路径 v 输出详细信息 z 使用gzip进行压缩归档，输出tgz。与x连用代表从tar.gz中提取文件 j 使用bzip2进行压缩归档，输出tbz。与j连用代表从tar.bz中提取文件 3、rsync：实现与本地系统或远程系统的目录内文件同步 语法：rsync [选项] &lt;源路径&gt; &lt;目标路径&gt;。源路径或目标路径的可能格式如下 本地文件或目录 远程文件或目录, 形式为 [user@]host:path 远程rsync服务器, 形式为 rsync://[user@]host[:port]/path 19. 正则表达式1、基本正则表达式（BRE）中常见的元字符 [.X] ：用于匹配在此位置的任意一个字符 [^X] ：用于匹配以X开头的内容 [X$] ：用于匹配以X结尾的内容，[^$]]会匹配空行 [] ：用于表示字符集，例如[bg]代表匹配开头为b或g的 如果插入字符出现在字符集中，则表否定，代表这些字符不应出现 使用连字符来表示范围，如[A-Za-z0-9]。如果连字符放在开头则表示其本身 2、扩展正则表达式（ERE）中常见的元字符（在BRE基础上增加） () ：用于分隔的括号 [|] ：代表或。如&#39;^(bz|gz|zip)&#39; [?] ：代表匹配其前面的元素0次或1次，如&#39;^\\(?[0-9][0-9][0-9]\\)?&#39; [*] ：代表匹配其前面的元素多次或0次，如[[:upper:]][[:upper:][:lower:] ]*. [+] ：代表匹配其前面的元素多次或至少1次 &#123;&#125; ：代表匹配其前面的元素指定次数 &#123;n&#125; ：用于匹配n次 &#123;n,m&#125; ：用于匹配至少n次，不多于m次（闭区间） &#123;n,&#125; ：用于匹配至少n次 &#123;,m&#125; ：用于匹配不多于m次 3、vim和less可以使用正则表达式进行搜索（vim支持的是BRE，所以使用额外元符号需要转义） 20. 文本处理1、cut ：从文本行中提取一段文字，并将其输出至标准输出 -f &lt;list&gt; ：只提取list所列举的字段，list可以是由&#39;,&#39;分隔的数字 -c &lt;dist&gt; ：只提取dist所列举的字符，list可以是由&#39;-&#39;给出的范围 -d &lt;arg&gt; ：分析时指定arg为分隔符，而不是tab字符 2、paste ：添加一个或多个文本列到文件中 3、join ：类似于SQL里的联结，需要有公共字段，然后将具有公共字段的两个字段加以组合 4、comm ：逐行比较两个已排序文件，结果以列的形式展开 语法：comm &lt;文件1&gt; &lt;文件2&gt; 第一列为文件1独有的文本行，第二列为文件2独有的文本行，第三列为共有的文本行 5、diff ：用于检测文件之间的不同, 支持多种输出形式, 并且具备一次性处理大文件集的能力 使用-c 开启上下文模式，直观地指示修改 使用-u 开启统一模式，比上下文模式的输出结果简短 6、patch ：通常和diff联合使用，对文件进行版本更新 7、sed ：以行为单位读取和处理文本，并根据提供的命令对文本进行自动化编辑 语法：sed [选项] &#39;命令&#39; 文件名 常用选项： -n ：安静模式，取消输出到标准输出 -i ：直接修改输入文件 -e ：允许指定多个命令，如sed [选项] -e &#39;命令1&#39; -e &#39;命令2&#39; ... -f ：允许从脚本读取命令，如sed [选项] -f 脚本文件 文件名 -r ：启用正则表达式 常用命令： s 用于替换，如s/旧文本/新文本/标志 标志可以为：g 全体替换、i 忽略大小写替换、&lt;num&gt; 替换第num个 分割符也可以使用#，避免转义 d 删除匹配行。如[地址]d。地址是以逗号分隔的行号区间，$代表末行 i 在匹配行之前插入新行。如[地址]i\\新文本。如果新文本有多行，可以使用 换行 a 在匹配行之后插入新行。如[地址]a\\新文本 c 将匹配行替换为新文本。如[地址]c\\新文本 8、aspell：一个交互式的拼写检查工具 21. 格式化输出1、nl ：用于为输出增加行数提示 2、fmt ：可以在格式化段落的同时，保留空白符和缩进 -w ：设置行宽 -p ：在每个段落的开头添加段落前缀 -c ：按段落中第一行的缩进，对整段进行处理 23. 编译程序1、大多数源码在其目录下有一个configure程序，用于检查并安装必要的工具和组件，生成makefile 2、使用make根据makefile，对.c文件编译为.o文件并链接该模块到程序上 make只构建所需要构建的内容，而不是全部构建 3、打包良好的源码经常包括一个特别的 make 文件，叫做 install，用于直接安装程序 通过sudo执行 make install 使其安装到bin目录下 24. 编写第一个 Shell 脚本1、#!字符序列又被称为shebang。用来告诉操作系统执行此shell脚本所用的解释器的名字 每个shell脚本都应该以shebang声明作为它的第一行，如#!/bin/bash -x ：可用于跟踪脚本执行流程 2、使用chmod 755（所有人可运行）或 700（只有文件所有者可运行）修改脚本的权限 3、shell语句末尾不使用分号 25. 启动一个项目1、为变量/常量赋值时，即隐式创建变量/常量 一个惯例是用全大写字母表示常量，全小写字母表示变量 如果错误地拼写了一个变量，shell 会将其创建并赋予默认值 2、常见的变量赋值类型 数字、字符串等基本格式 包含可展开的内容，如 c=&quot;a string and $b&quot;，或e=$((5 * 7)) 命令执行的结果，如 d=$(ls -l foo.txt) 3、here document ：一种 I/O 重定向形式。其特性为 可随意嵌入引号而不会被 shell 识别 以command &lt;&lt; token开始，以 token 结束 token可以是_EOF_，command 可以是cat 如果将 &lt;&lt; 替换为 &lt;&lt;-，则 shell 会忽略每一行开头的缩进，提高可读性 26. 自顶向下设计1、shell函数和C语言的函数定义类似，但不传参，需至少包含一条指令 如果需要传参，可使用位置参数，将option输入 2、在shell的引号内创建变量时，在其前面添加local关键字以创建局部变量，不需要再添加 $ 3、通过在.bashrc文件中编写函数，可以起到和创建别名一样的效果 27. if分支结构1、if 的语法 if [commands]; then commands elif [commands]; then commands ... else commands fi 其中，用方括号括起来的command，实际等同于执行test command，即检查command的执行情况 使用复合命令[[expression]]，可以将command转变为expression 该模式下，引入了正则表达式判断符 =~，如：[[&quot;$INT&quot; =~ ^-?[0-9]+$]] 该模式下，== 操作符支持类型匹配，如：[[$FILE == foo.*]] 2、指令在执行时会返回参数，通过 变量 $? 可以查看其值 布尔值true的 $? 值为0，false为1 返回值可能是0到255的任意整数 3、文件表达式：用于计算文件状态 file1 -ef file2 ：file1 和 file2 拥有相同的索引号 file1 -nt file2 ：file1 新于 file2 file1 -ot file2 ：file1 早于 file2 -[文件属性] file ：file存在且拥有[文件属性] -[文件类型] file ：file存在且是一个[文件类型] 4、字符串表达式：用于计算字符串 -n string ：string 的长度大于零 -z string ：字符串 string 的长度为零 28. 读取键盘输入1、read：从标准输入读取单行数据 语法：read [-options] [variable...]variable可以有多个 如果接受到变量值数目少于期望的数字，那么额外的变量值为空，否则会覆盖到最后一个变量中 常用option： -a [数组] : 将读取到的数据存储到特定数组中（从0开始） -d [字符串] : 使用指定的字符串的第一个字符作为输入结束的指示符，而不是换行符 -n [num] : 读取num个字符 -p [prompt] : 为输入增加提示信息prompt -r : 不把反斜杠字符解释为转义字符 -s : 不回显输入，适用于密码等敏感信息输入 -t [seconds] : 使read在seconds秒后超时，并返回一个非零退出状态 2、IFS：一个shell变量，用于定义shell如何分割单词 默认值：空格、制表符和换行符 可以在read指令前临时更改IFS，使其适应不同字符串的分割情形 形如：IFS=&quot;:&quot; read -r first_name last_name age city &lt; data.txt 29. while&#x2F;until 循环1、while 的语法 while [commands]; do commands done 当遇到一个非零退出状态时，while 退出循环 2、continue和break指令和C语言中的用法一致 3、当遇到一个非0退出状态时，until 不退出，直到接受了一个为0的退出状态 until 的语法与 while 类似 30. 疑难排解1、set ：为脚本中的特点区域提供跟踪能力 使用set -x 作为追踪开始行，set +x 作为追踪结束行 31. 流程控制：case 分支1、case 的语法 case 单词 in 模式) 命令... ;;&amp; esac 常用模式： a) 若单词为a，则匹配 [[:alpha:]]) 若单词是一个字母字符，则匹配 ???) 若单词只有 3 个字符，则匹配 *.txt) 若单词以.txt为扩展名，则匹配 *) 匹配任意单词。可以把这个当成C语言中的default来用 可以使用竖线字符作为分隔符，把多个模式结合起来 32. 位置参数1、位置参数：一个变量集合，包含命令行中所有的参数（如option、argument等） 常用于给shell脚本或shell函数传递参数 如执行：posit-param a b c d，则能通过 $0 - $4 五个位置参数得到特定值 $0 总是存在，为执行脚本的命令（路径），如/home/me/bin/posit-param 大于9的位置参数需要用花括号括起来，如 $&#123;10&#125; 通常与case连用，以达到执行option的效果 2、$# ：可用于确定参数的个数 3、$* ：代表命令行中所有的参数，但把所有参数看成一个整体，所以长度是1 4、$@ ：也代表命令行中所有的参数，但把所有参数按原位置独立区分（更实用） 33. 流程控制：for 循环1、for 的语法 for 遍历变量 in [words]; do commands done 或（与C语言一致） for ((expression1; expression2; expression3)); do commands done words列表的创建是多样化的，如： 路径名展开：for i in distros*.txt 花括号展开：for i in &#123;A..D&#125; 命令替换：for i in $(strings $1) 34. 字符串和数字1、空变量展开 $&#123;parameter:-word&#125; ：若parameter为空或未定义，则展开结果为word 位置参数或其他特殊参数不能以该方式赋值 $&#123;parameter:?word&#125; ：若parameter为空或未定义，则将错误信息输出到标准错误输出中 $&#123;parameter:+word&#125; ：若parameter已设置且不为空，则展开结果为word $&#123;parameter:=word&#125; ：如果parameter为空或未定义，则展开结果为word 同时，会将word赋值给parameter 2、字符串展开 $&#123;#parameter&#125; ：获取字符串长度 $&#123;parameter:offset&#125; ：从offset开始提取length长度的子字符串，不加length则提取到末尾 $&#123;parameter#pattern&#125; ：从字符串开头删除最短匹配pattern $&#123;parameter##pattern&#125; ：从字符串开头删除最长匹配pattern $&#123;parameter%pattern&#125; ：从字符串结尾删除最短匹配pattern $&#123;parameter%%pattern&#125; ：从字符串结尾删除最长匹配pattern $&#123;parameter/pattern/string&#125; ：查找并替换第一个匹配pattern $&#123;parameter//pattern/string&#125; ：查找并替换所有匹配pattern $&#123;parameter/#pattern/string&#125; ：仅当匹配pattern在字符串开头时替换 $&#123;parameter/%pattern/string&#125; ：仅当匹配pattern在字符串结尾时替换 $&#123;parameter,,&#125; ：全部转换为小写 $&#123;parameter,&#125; ：首字母转换为小写 $&#123;parameter^^&#125; ：全部转换为大写 $&#123;parameter^&#125; ：首字母转换为大写 3、整数求值与展开 算术表达式展开 ：$((expression)) base#number ：以base为基数的数 数值运算、逻辑运算、位运算符号与C语言中的一致，除了幂运算：** 4、bc ：一个独立的命令行计算器程序，支持高精度计算 可以读取脚本文件，其语法类似于C语言。如 bc &lt; foo.bc 也可以交互式使用，如 bc &lt;&lt;&lt; &quot;2+2&quot; 35. 数组1、bash 只支持一维数组 2、数组的创建 显式创建：declare -a 数组名 隐式创建：数组名[index]=value 3、数组的赋值 列表形式：数组名=(value1 value2 value3 ...) 索引形式：数组名=([5]=&quot;value1&quot; [1]=&quot;value1&quot; [3]=&quot;value1&quot; ...) 4、数组的访问 使用下标 * 可以访问所有数组元素，但把所有参数看成一个整体，所以长度是1 使用下标 @ 也可以访问所有数组元素，但把所有参数按原位置独立区分 通常与for循环连用，用于遍历所有元素 5、数组的操作 $&#123;#数组名[@]&#125; ：获取数组长度 $&#123;#数组名[index]&#125; ：获取特定元素的长度 $&#123;!array_name[@]&#125; ：获取已使用的下标列表 数组名+=(element1 element2 ...) ：在数组末尾追加 unset 数组名：删除数组 unset 数组名[index]：删除数组元素 array2=(&quot;$&#123;数组名[@]&#125;&quot;)：复制数组 6、关联数组：类似于map，使用字符串作为索引 声明：declare -A 数组名 36. 奇珍异宝1、组命令和子shell 目的：将多个命令组合在一起，主要用于方便地管理重定向和管道 组命令：形如&#123; command1; command2; [command3; ...] &#125; 花括号与命令之间必须有空格 最后一个命令必须以分号或换行符结尾 对环境变量的修改会影响当前shell 子shell：形如(command1; command2; [command3;...]) 其功能与组命令类似，但在新的shell环境中执行命令 当子shell结束后, 创建的环境变量会被消除 2、进程替换：一种特殊的展开，允许将子 shell 的输入/输出当作普通文件处理 &lt;(list) ：适用于产生标准输出的进程 &gt;(list) ：适用于接受标准输入的进程 3、命名管道：一种特殊的文件，用于在不同终端间建立连接 特性： 数据从一端进入，从另一端流出，遵循FIFO原则 如果管道的一端没有进程来读取数据，写入端会挂起（阻塞） 创建：mkfifo 管道名 语法： 在一个终端中重定向，如ls -l &gt; pipe1 随后在另一个终端中读取，如cat &lt; pipe1 4、trap ：用于捕获特定信号 语法：trap argument signal/[signal...] argument是一个字符串，被读取并当作一个命令 5、wait ：用于实现进程间的异步执行 语法：wait $&#123;pid&#125;","tags":["Linux","Shell"]},{"title":"关于","path":"/about/index.html","content":"友链关于昵称简介 关于本站 本站没有任何推广和打赏链接，如果您觉得哪个作品不错，欢迎去对应的仓库点个赞，或者在对应的文章下面留言互动一下。 开源项目无任何盈利目的，只在工作闲暇时间进行维护，有相关需求请前往对应项目提 Issue 进行反馈，通过私人邮件询问开源项目问题可能得不到答复。"},{"title":"收藏","path":"/bookmark/index.html","content":"…"},{"title":"友链","path":"/friends/index.html","content":"友链关于小伙伴们如果宇宙中真有什么终极的逻辑，那就是我们终有一天会在舰桥上重逢，直到生命终结。 [2023-12] 友链失联了怎么办?添加友链后如果网站长期无法访问，可能会被取消友链！如果您的网站恢复了，可以在申请友链时创建的那条 issue 中评论告知。 朋友们近期的文章 如何交换友链？ 您的网站应满足以下全部条件： 安全合规：合法的、非营利性、无木马植入的 HTTPS 站点。 非空壳网站：网站内发布至少 五篇 原创文章，内容题材不限。 我们需要有一定的有效互动： 先友后链：与博主有至少 半年 的有效互动，例如 issue 或者评论留言。 [2023-12] 友链申请条件变更说明降低了对商业广告的要求，可以有但是不能太多。提高了「有效互动」的定义：5次更改为半年。 我已满足全部条件，快告诉我如何交换友链！如果您没有满足上述条件，即时提交了申请也不会通过哦～第一步：新建 Issue新建 GitHub Issue 按照模板格式填写并提交。为了提高图片加载速度，建议优化头像：打开 压缩图 上传自己的头像，将图片尺寸调整到 144px 后下载。将压缩后的图片上传到 去不图床 或者其它稳定的图床并使用此图片链接作为头像。第二步：添加友链并等待管理员审核请添加本站到您的友链中：1234title: xxxurl: https://xxx.comavatar: screenshot: 待管理员审核通过，添加了 active 标签后，回来刷新即可生效。如果您需要更新自己的友链，请直接修改 issue 内容，大约 3 分钟内生效，无需等待博客重新部署。"},{"title":"朋友文章","path":"/friends/rss/index.html","content":""},{"title":"探索","path":"/explore/index.html","content":"…"},{"title":"Page","path":"/page/index.html","content":"This is a page test."}]